/*******************************************************************************
                      C++  类和对象 -- 知识要点

            一. 类的基本概念
                1. 类的定义、C++对象、访问数据成员
                2. 类的成员函数
                3. 类访问修饰符
                4. 构造函数与析构函数
                5. C++拷贝构造函数
                6. 友元函数
                7. 内联函数
                8. this指针
                9. const对象和const成员函数
                10. 指向类的指针
                11.类的静态成员

            二. 类的操作
                1.类对象的指针和引用
                2.指针作为数据成员
                3.控制对类的访问
                4.副本构造函数的重要性
                5.类的引用
                6.类的自动转换和强制类型转换

            三. 类和动态内存分配
                1.动态内存和类
                2.改进后的新String类
                3.在构造函数中使用new时应注意的事项
                4.有关返回对象的说明
                5.使用指向对象的指针
                6.队列模拟

            四. 运算重载符与重载函数
                1.运算重载符
                2.可以重载的运算符
                3.实现重载运算符
                4.运算符函数术语
                5.重载赋值运算符
                6.重载算术运算符
                7.重载下标运算符
                8.重载类型转换
                9.重载递增和递减运算符
                10.智能指针
                11.重载运算符new和delete
                12.函数重载

            五. 类继承
                1.类的继承
                2.继承下的访问控制
                3.把类的成员声明为protected
                4.派生类成员的访问级别
                5.派生类中的构造函数操作
                6.继承中的析构函数
                7.多重继承

            六. 虚函数和多态性
                1.理解多态性
                2.多态性的成本
                3.纯虚函数
                4.通过指针释放对象
                5.类成员的指针

            七. 类模板
               1.什么是类模板
               2.定义类模板
               3.模板的显式实例化
               4.类模板的友元
               5.其他

            八. 数据抽象、数据封装、抽象类

******************************************************************************/
一. 类的基本概念

1. 类的定义、C++对象、访问数据成员
(1) 类的定义:
    class Box
    {
       public:
          double length;
          double breadth
          double height;
    };

(2) 声明类的对象: Box box1;
(3) 类的对象的公共数据成员可以使用直接成员访问运算符(.)来访问
    box1.length = 5.0;

    ***私有的成员和受保护的成员不能使用直接成员访问运算符(.)

2. 类成员函数
   (1)含义: 定义和原型写在类定义内部的函数
   (2)成员函数的定义
      <1>类内定义
         class Box
         {
            public:
                double length;
                double breadth;
                double height;

                double getVolume(void)
                {
                  return length*breadth*height;
                }
         };

      <2>使用范围解析运算符(::)
         double Box::getVolume(void)
         {
           return length*breadth*height;
         }

3. 访问修饰符
   (1) 3 个访问修饰符: public, private, protected
       <1> 每个标记区域在下一个标记区域开始之前或者遇到类主体结束右括号之前都是有效的
       <2> 成员和类的默认访问修饰符是private

   (2) 公有成员(public)
       <1> 公有成员在程序中类的外部是可以访问的
       <2> 把类的公有成员放在私有成员前面：公有成员更具有吸引力，因为它可以与外界的接口

   (3) 私有成员(private)
       <1> 私有成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员
       <2> 实际操作中，一般在私有区域定义数据，在公有区域定义函数
       <3>访问私有成员
         《1》访问器成员函数：如 double getLength(){ return length;}
                * 这种函数通常定义在类定义中，因为它们非常简短，在默认情况下是内联函数
                * 如果定义在类的外部，则应声明为 inline ：
                  inline double Box::getLength(){return length;}
         《2》变异成员函数：如 void setLength(double len){length = len;}
                * 是为了能在类的外部修改数据成员，但又不允许直接访问数据成员

   (4) 保护成员(protected)
       <1> 保护成员与私有成员十分相似，但有一点不同：保护成员在派生类中是可以访问的

4. 构造函数与析构函数
   (1)构造函数
      <1> 类的一种特殊成员函数，它会在每次创建类的新对象时执行
      <2> 构造函数的名称与类的名称完全相同，不返回任何类型，也不返回void
      <3> 构造函数的主要作用是在创建类对象时，为它的所有数据成员赋予并验证初始值
      <4> 声明的类至少有一个构造函数，因为类的对象总是用构造函数创建的
      <5> 默认的构造函数：
         《1》如果没有定义构造函数，则编译器会提供有个默认的构造函数
         《2》默认的构造函数没有参数

    (2)析构函数
       <1> 类的一种特殊的成员函数，它会在每次删除所创建的对象时执行
       <2> 析构函数的名称与类名完全相同，只是在前面加了个波浪号(~)作为前缀，不返回任何值，也不能
           带有任何参数
       <3> 析构函数有助于在跳出程序(比如关闭文件、释放内存等)前释放资源

    (3)构造函数的应用
       <1>带参数的构造函数: 构造函数可以带参数，在创建对象时就会给对象赋初始值
       <2>例子

          class Line
          {
             public:
                void setLength(double len);
                double getLength(void);
                Line();  //这是构造函数
                Line(double len);  //带参数的构造函数
                ~Line();           //这是析构函数
          };

          Line::Line(void)   //不带参数的构造函数
          {
            cout<<"Object is being created"<<endl;
          }

          Line::Line(double len)
          {
            cout<<"Object is being created, length="<<len<<endl;
            length = len;
          }

          Line::~Line(void)
          {
            cout<<"Object is being deleted"<<endl;
          }

    (4)析构函数的应用


5. 拷贝构造函数
   (1) 一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象

   (2) 拷贝构造函数的用途：
       <1> 通过使用另一个同类型的对象来初始化新创建的对象
       <2> 复制对象把它作为参数传递给函数
       <3> 复制对象，并从函数返回这个对象

   (3) 拷贝构造函数的定义
       <1> 若在类中没有定义宝贝构造函数，编译器会自行定义一个；
           若类带有指针变量，并有动态内存分配，则必须有一个拷贝构造函数
       <2> 格式：
           classname (const classname &obj)   // obj 是一个引用对象
           {
             // 构造函数主体
           }

   (4) 什么情况使用拷贝构造函数
       <1> 一个对象以值传递的方式传入函数体
       <2> 一个对象以值传递的方式从函数返回
       <3> 一个对象需要通过另一个对象进行初始化


6. 友元函数
   <1> 类的友元函数定义在类外部，但有权访问类的所有私有成员和保护成员
   <2> 尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数
   <3> 友元也可以是一个类，该类被称为友元类, 这种情况下，这个类及其所有成员都是友元

   <4> 友元的声明
       class Box
       {
          double width;

       public:
          double length;
          friend void printWidth(Box box);  // 定义友元函数
          friend class ClassTwo;            // 定义友元类
          void setWidth(double wid);
       }


7. 内联函数
   (1) 如果一个函数是内联的，意味着，在编译时编译器会把该函数的代码副本放置在每个调用该函数的地方
   (2) 对内联函数进行任何修改，都需要重新编译函数的所有客户端
   (3) 如何定义一个内联函数？在函数名前面放置关键字inline
   (4) 在类定义中定义的的函数都是内联函数，即使没有使用inline说明符
   (4) 内联函数的使用
       <1> 为什么使用内联函数？ 为了解决程序中函数调用的效率问题
       <2> 内联函数一般都是1-5行的小函数
       <3> 使用内联函数需要注意：
          《1》内联函数内不允许使用循环语句和开关语句
          《2》n内联函数的定义必须出现在内联函数第一次调用之前

8. this指针
   (1)每个对象都能通过this指针来访问自己的地址
   (2)this指针是所有成员函数的隐含参数
   (3)只有成员函数才有this指针


9. const对象与const成员函数

10. 指向类的指针
    (1)访问指向类的指针的成员,需要使用成员访问运算符->
    (2)例子
       int main()
       {
         Box Box1(3.3, 1.2, 1.5);
         Box Box2(8.5, 6.0, 2.0);
         Box *ptrBox;

         //保存第一个对象的地址
         ptrBox = &Box1;

         //现在尝试使用->来访问成员
         cout<<"Volume of Box1："<< ptr->Volume() <<endl;

         ptrBox = &Box2;

         //现在尝试使用->访问成员
         cout<<"Volume of Box2："<< ptr->Volume()<<endl;

         return 0;
       }

11. 类的静态成员
    (1)使用static关键字把类成员定义为静态
    (2)静态成员的初始化必须放在类外部，使用范围解析运算符::来进行初始化
    (3)静态成员函数即使在类对象不存在的情况下也能被调用
    (4)静态函数只要使用类名加范围解析运算符::就可以访问
    (5)静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数
    (6)静态成员函数与普通成员函数:
       <1>静态成员函数没有this指针，只能访问静态成员
       <2>普通成员函数有this指针，可以访问类中的任意成员
    (7)类中特殊成员变量的初始化问题：
       <1>常量变量:必须通过构造函数参数列表进行初始化
       <2>引用变量:必须通过构造函数参数列表进行初始化
       <3>普通静态变量:要在类外通过::初始化
       <4>静态整型变量:可以直接在定义的时候初始化
       <5>静态非整型变量:要在类外通过::初始化


********************************************************************************

四. 运算重载符与重载函数

    * 函数重载与运算符重载:在同一作用域中的某个函数和运算符指定多个定义
    * 重载的调用： 当调用一个重载函数或重载运算符时，编译器通过把使用的参数类型与定义中的参数类型
      进行比较，决定选用最合适的定义

    1.运算重载符
      (1)我们可以重定义大部分C++内置的运算符
      (2)重载的运算符的函数名是由关键字 operator 和其后要重载的运算符符号构成的
    2.可以重载的运算符
           3.实现重载运算符
           4.运算符函数术语
           5.重载赋值运算符
           6.重载算术运算符
           7.重载下标运算符
           8.重载类型转换
           9.重载递增和递减运算符
           10.智能指针
           11.重载运算符new和delete
    12.函数重载
       (1)在同一作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数必须不同

********************************************************************************


********************************************************************************

五. 继承
1.类的继承
  (1)继承是面向对象程序设计中最重要的概念
  (2)继承允许我们依据另一个类来定义一个类
  (3)当创建一个类时，只需指定新建的类继承了一个已有的类的成员即可.
     基类:已有的类
     派生类:新建的类
  (4)定义一个派生类，可以使用一个类派生列表来指定基类.如
     class Rectangle: public Shape
     {

     };

2.继承下的访问控制
  (1)派生类可以访问基类中所有的非私有成员
  (2)继承类型
    <1>公有继承(public)(通常使用)
    <2>保护继承(protected)(几乎不用)
    <3>私有继承(private)(几乎不用)

       基类成员              public继承       protected继承        private继承
       public成员             public          protected           private
       protected成员          protected       protected           private
       private成员            不能直接访问      不能直接访问          不能直接访问

3.把类的成员声明为protected
4.派生类成员的访问级别
5.派生类中的构造函数操作
6.继承中的析构函数
7.多重继承
  (1)多继承即一个子类可以有多个父类
     class Rectangle: public Shape, public PaintCost
     {
        public:
              int getCost(int area)
              {
                return area * 70;
              }
     };

********************************************************************************

********************************************************************************

六. 虚函数和多态性
    1.理解多态性
      (1)多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数
      (2)当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态
      (3)有了多态，我们可以有多个不同的类，都带有同一个名称但具有不同实现的函数,函数的参数
         甚至可以是相同的
      (4)我们使用虚函数是想实现动态链接：在程序中任意点可以根据所调用的对象诶性来选择调用的函数

    2.多态性的成本
    3.纯虚函数
      (1)虚函数：在基类中使用关键字virtual声明的函数
         纯虚函数: virtual void function() = 0, 表明纯虚函数没有定义
      (2)在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数
      (3)包含纯虚函数的类是抽象类，抽象类不能定义实例


    4.通过指针释放对象
    5.类成员的指针

********************************************************************************


********************************************************************************
八. 数据抽象、数据封装、接口(抽象类)

1. 数据抽象
   (1)数据抽象:只向外界提供相关信息，并隐藏其后台的实现细节
   (2)数据抽象是一种依赖于接口和实现分离的编程技术
   (3)访问标签强制抽象：在C++中，我们使用访问标签来定义类的抽象接口
      <1> 一个类的数据抽象视图是由它的公共成员来定义的
      <2> 私有部分对使用类型额代码隐藏了实现细节
   (4)数据抽象的好处
      <1>类的内部受到保护，不会因无意的用s户低级错误导致对象状态受损
      <2>类实现可能随着时间的推移而发生变化，以便应对不断变化的需求

   (5)设计策略
      <1>抽象把代码分离为接口和实现
      <2>在设计时，必须保持接口独立于实现，这样，如果改变底层实现，接口也将保持不变


2. 数据封装
   (1)C++程序的两个基本要素：
      <1>程序语句: 程序中执行动作的部分，被称为函数
      <2>程序数据: 数据是程序的信息，会受到程序函数的影响
   (2)数据封装：函数与数据捆绑在一起进行封装
   (3)数据抽象：仅仅将接口暴露，细节隐藏
   (4)数据隐藏: 数据隐藏属于面向对象编程中的封装的特性
   (4)C++通过创建类来支持封装和数据隐藏(public、protected、private)
   (5)设计策略
      <1> 设计类的成员为私有，除非真的要对其暴露，确保封装性
      <2> 包括对于虚函数，也是如此

3. 接口(抽象类)
   (1)C++接口是使用抽象类来实现的
   (2)设计抽象类的目的，是为了给其他类提供一个可以继承的适当的基类
   (3)抽象类不能被用于实例化对象，它只能作为接口使用.如果试图实例化一个抽象类的对象，会导致编译错误
   (4)可用于实例化对象的类被称为具体类
   (5)设计策略:
      <1>使用一个抽象基类为所有的外部应用程序提供一个适当的、通用的、标准化的接口
      <2>然后，派生类通过继承抽象基类，就把所有类似的操作都继承下来
      <3>外部应用程序提供的功能(公有函数)在抽象基类中是以纯虚函数的形式存在的
         这些纯虚函数在相应的派生类中被实现



********************************************************************************
