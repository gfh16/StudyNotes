/*******************************************************************************
                          C++ 存储类
                1. 存储类定义C++ 程序中变量/函数的范围和生命周期.
                2. C++ 程序可以使用的存储类
                  (1) auto
                  (2) register
                  (3) static
                  (4) extern
                  (5) mutable
                  (6) thread_local(C++11)

                3. 存储期 与 作用域
                   (1) 前者从时间角度分析
                   (2) 后者从空间角度分析

链接：https://www.cnblogs.com/bhlr/p/6689734.html
*******************************************************************************/
/*：
1. auto 声明自动变量
  (1) 声明变量时根据初始化表达式自动推断该变量的类型
      auto f = 3.14;         // double
      auto s("hello");       // const char*
      auto z = new auto(9);  // int*
  (2) 动态存储：在程序运行期间，系统对变量动态地分配存储空间

2. static 声明静态局部变量
   (1) static int a = 3;
   (2) 静态存储：程序运行期间，系统对变量分配固定的存储空间

   **************************************************
   a. 数据放在静态存储区和动态存储区,全局变量全部放在静态存储区中，在程序开始执行时给全局变量
      分配存储单元，程序执行完毕就释放这些空间。程序执行过程中他们占据固定的存储单元。
   b. 动态存储区存放以下的数据：函数形参、函数中的自动变量等。
   c. 根据函数调用的情况，系统对局部变量动态地分配和释放存储空间
   d. 函数的局部变量，如果不用关键字static加以声明，系统默认为自动存储类型
   e. 用static声明静态局部变量：在下一次该函数调用时，该变量保留上一次函数结束时的值
   *****************************************************************************

   =============================================================================
   什么时候需要使用局部静态变量？
   1. 需要保留函数上一次调用结束时的值
   2. 如果初始化后，变量只被引用而不改变其值，使用静态局部变量比较方便，以免每次调用时重新赋值
   3. 静态存储多占内存，降低程序可读性，如非必要，不要多用。
   =============================================================================

   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
   1. static全局变量与普通全局变量的区别
      限制作用域。非静态全局变量的作用域是这个源文件，静态全局变量限制了其作用域，只有在定
      义该变量的源文件内有效. static全局变量只初始化一次，防止在其他文件单元中被引用
   2. static局部变量和普通局部变量的区别
      改变变量的生存期。
   3. static 函数与普通函数的区别
      static函数与普通函数作用域不同，仅在本文件。static函数在内存中只有一份，普通函数在每个
      被调用的维持一份拷贝
   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

   -----------------------------------------------------------------------------
   C++ 中static关键字的作用总结
    1. 隐藏(最重要)
       当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性
    2. 保持变量内容的持久
    3. 默认初始化为0
       ==> 首先static的最主要功能是隐藏，其次因为static变量存放在静态存储区，所以具备持久性
           和默认值0
    4. C++中的类成员声明static

   链接：
   https://www.cnblogs.com/songdanzju/p/7422380.html

3. register 声明寄存器变量
   (1) 一般的变量存放在内存中.为提高执行效率，C++ 允许将局部变量存放在CPU的寄存器中，需要用
       时直接从寄存器取出参加运算，不必再到内存中去取

4. extern 声明外部变量
   (1) 全局变量(外部变量)是在函数的外部定义，它的作用域为从变量的定义处开始，到本程序文件的结尾。
   (2) 用extern来声明全局变量，以扩展全局变量的作用域
       <1> 在一个文件内声明全局变量
        "提前引用声明": 用关键字extern对该变量作外部变量声明，就可以从声明处起，合法地引用
         该全局变量
       <2> 在多文件的程序中声明外部变量
        "外部变量声明": 如果一个程序包含两个文件，在两个文件中都要用到同一个外部变量num，不能
         分别在两个文件中各自定义一个外部变量num。
         正确的做法是：在任一个文件中定义外部变量num，而在另一个文件中用extern对num作外部变量
         声明
    (3) extern 只能用来声明已定义的外部变量，而不能用于变量的定义

    ============================================================================
    extern 关键字主要修饰变量或函数，表示该函数可以跨文件访问，或者表明该变量在其他文件定义，在此引用

    1.extern修饰变量
      (1) 如果某变量int m在a.cpp中定义声明，则其他b.cpp文件访问时，需要用extern声明该变量才可以
      (2) 如果在.*h中声明，其他文件使用时，则需要包含头文件即可，无需再声明，建议只在头文件中
          声明就好了
      (3) extern可以声明无数次，但只能定义一次，否则会出现链接错误
      (4) 如果一个变量声明于代码块内部，在它前面添加extern表示引用的是全局变量而不是局部变量

    2.extern修饰函数
      extern修饰函数和变量没有区别

    3. extern用于从C\C++相互调用

    链接：https://www.cnblogs.com/qinguoyi/p/10100777.html

    ============================================================================



 5. C++ 变量属性小结
    (1) 储存类别：C++允许使用auto、static、register和extern 4中存储类别
    (2) 作用域：  只程序中可以引用该变量的区域
    (3) 存储期：  指变量在内存中的存储期限
*/



////  静态局部变量的值
#if 0

#include<iostream>
using namespace std;

int f(int a)
{
  int b =0;

  static int c =3;   // 输出 f(a) = 7, 8, 9
  int c = 3;        // 输出 f(a)= 7, 7 , 7

  b = b+1;
  c = c+1;
  return a+b+c;
}

int main()
{
  int a = 2;
  for(int i=0; i<3; i++)
  {
    cout<< f(a) <<" "<<endl;
  }

  return 0;
}

#endif



////  用extern对外部对外部变量作提前引用声明，以扩展程序文件的作用域
#if 1

#include<iostream>
using namespace std;

int max(int, int);

int main()
{
//  extern int a, b;    // 输出：5
  int a, b;             // 输出：0
  cout<< max(a,b) <<endl;

  return 0;
}

int a=5, b=-7;
int max(int x, int y)
{
  return x>y?x:y;
}

#endif
