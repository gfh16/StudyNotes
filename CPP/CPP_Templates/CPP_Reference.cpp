/******************************************************************************
                              引用
     1. 引用是给已定义的变量起别名
        引用：在声明的时候一定要初始化

     2. 引用 && 指针
        (1) 不存在空引用。引用必须连接到一块合法的内存。
        (2) 一旦引用被初始化一个对象，就不能被指向到另一个对象。 指针可以在任何时候指向到另一个对象。
        (3) 引用必须在创建时被初始化。指针可以在任何时间被初始化。
        (4) 引用比指针更安全。因为指针有这样的问题：空指针、野指针、可随时改变指向
        (5) 指针指向一块内存，它的内容是所指内存的地址；
            而引用则是某块内存的别名，引用不改变指向


     3. 引用& 与 取地址&
        (1) 和类型在一起的是引用， 和变量在一起的是取地址



参考链接：https://blog.csdn.net/qq_26501341/article/details/58192662

*******************************************************************************/
/*
1. 把引用作为参数
   // 比传一般的参数更加安全
*/
#if 0

#include<iostream>
using namespace std;

void swap(int& x, int& y);

int main()
{
  int a = 100;
  int b = 200;

  cout<<"交换前，a的值："<< a << endl;
  cout<<"交换前，b的值："<< b << endl;

  swap(a, b);

  cout<<"交换后, a的值："<< a << endl;
  cout<<"交换后, b的值："<< b << endl;

  return 0;
}

void swap(int& x, int& y)
{
  int temp;
  temp = x;
  x = y;
  y = temp;

  return;
}

#endif



////////////////////////////////////////////////////////////////////////////////
/*
2. 把引用作为返回值
// 通过使用引用来代替指针，会使C++ 程序更容易阅读和维护
// 当函数返回一个引用时，则返回一个指向返回值的隐式指针

*/
#if 0

#include<iostream>
using namespace std;

double vals[] = {10.1, 12.6, 33.1, 24.1, 50.0};

double& setValues(int i)
{
  return vals[i];   // 返回第 i 个元素的引用
}

int main()
{
  cout<< "改变前的值" << endl;
  for(int i=0; i<5; i++)
  {
    cout<< "vals[" << i << "]=" << vals[i] << endl;
  }

  setValues(1) = 20.23; //改变第2个元素
  setValues(3) = 70.8;  //改变第4个元素

  cout<<"改变后的值："<<endl;
  for(int i=0; i<5; i++)
  {
    cout<< "vals[" << i << "]=" << vals[i] << endl;
  }

  return 0;
}

#endif
