 /*******************************************
            makefile 知识详解

  参考链接：
  1. https://blog.csdn.net/zong596568821xp/article/details/81134406
  2. https://blog.csdn.net/weixin_38391755/article/details/80380786 (makefile教程)
  3. https://seisman.github.io/how-to-write-makefile/rules.html


      1. 什么是makefile?
         Makefile文件描述了整个工程的编译、连接等规则. 具体内容包括;
        (1) 哪些源文件需要编译以及如何编译
        (2) 需要创建哪些库文件
        (3) 如何产生这些库文件
        (4) 如何最后产生我们想要的可执行文件

      2. 编译与链接
        (1) 编译：把源文件(.cpp文件)编译成中间代码文件(windows:.obj， unix: .o)
        (2) 链接：把大量的 Oject File合成可执行文件
        (3) 给中间文件打包：windows,"库文件"，.lib文件 ；unix下，Archive File, .a文件

      3. make工作流程
        (1) make会在当前目录下找名字叫"Makefile"或"makefile"的文件
        (2) 如果找到，它会找文件中的第一个目标文件(target),并把这个文件作为最终的目标文件
        (3) 如果目标文件不存在，或是目标文件所依赖的后面的 .o 文件的文件修改时间要比目标文件
            新，那么它就会执行后面所定义的命令来生成 edit 这个文件
        (4) 如果目标文件所依赖的 .o 文件也存在，那么make会在当前文件中找目标.o文件的依赖性，
            如果找到则再根据那一个规则生成.o文件
        (5) 当然，你的C文件和H文件是存在的，于是make会生成.o文件, 然后再用.o文件生成make的
            终极任务, 也就是可行文件 edit 了

********************************************/
1. Makefile介绍

   *****************************************************************************
    编写Makefile的规则：
    1. 如果这个工程没有编译过，那么我们的所有C文件都要编译和链接
    2. 如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序
    3. 如果这个工程的头文件被修改了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序
   *****************************************************************************

  1.1 Makefile的规则
      (1)makefile书写格式：

         target...:prerequisites...
         command
         ...
         ...

        target:目标文件，可以是 Object File，也可以是执行文件，还可以是一个标签(Label)
        prerequisites:要生成那个target所需要的文件或是目标
        command:make 需要执行的命令 (任意的shell命令)

      (2)makefile的本质是解决文件的依赖关系：
         target 这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中

      (3) makefile的规则：(makefile中最核心的内容)
          prerequisites中如果有一个以上的文件比target文件要新的话，commmand所定义的命令就会被执行.

      (4) makefile 中三个重要变量：
          $@  目标文件
          $^  所有的依赖文件
          $<  第一个依赖文件

      (5) 在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，一定要以一个
          Tab 键作为开头

  1.2 make是如何工作的
      (1) make会在当前目录下找名字叫"Makefile"或"makefile"的文件
      (2) 如果找到，它会找文件中的第一个目标文件(target),并把这个文件作为最终的目标文件
      (3) 如果目标文件不存在，或是目标文件所依赖的后面的 .o 文件的文件修改时间要比目标文件
          新，那么它就会执行后面所定义的命令来生成 edit 这个文件
      (4) 如果目标文件所依赖的 .o 文件也存在，那么make会在当前文件中找目标.o文件的依赖性，
          如果找到则再根据那一个规则生成.o文件
      (5) 当然，你的C文件和H文件是存在的，于是make会生成.o文件, 然后再用.o文件生成make的
          终极任务, 也就是可行文件 edit 了



2. Makefile总述
   (1) Makefile里面有什么：显式规则、隐晦规则、变量定义、文件指示和注释
   (2) Makefile的文件名：大多数的make都支持"makefile"和"Makefile"这两种默认文件名.
       建议使用 "Makefile"
   (3) 引用其他的Makefile: 可以通过include关键字把别的Makefile包含进来

   (4) make的工作方式
      <1> 读入所有的Makefile
      <2> 读入被include的其他Makefile
      <3> 初始化文件中的变量
      <4> 推到隐晦规则，并分析所有规则
      <5> 为所有的目标文件创建依赖关系链
      <6> 根据依赖关系，决定哪些目标需要重新生成
      <7> 执行生成命令

3. Makefile书写规则
  (1) 规则包含两部分：一个是依赖关系，一个是生成目标的方法
      <1> Makefile中只应该有一个最终目标，因此，Makefile中规则的顺序非常重要
      <2> 一般来说，定义在Makefile中的目标可能会有很多，但是第一条规则中的目标将被确立为最终
          的目标
      <3> 如果第一条规则中的目标有很多个，那么，第一个目标会成为最终的目标

   (2) Makefile规则的语法
       targets:prerequisites
       command
       ...

       语法的说明：
       targets: 文件名，以空格分开，可以使用通配符。一般来说，目标基本是一个文件，但也可能是多个文件
       prerequisites: 目标所依赖的文件。如果其中的某个文件要比目标文件要新，那么，目标就被认为
                是“过时的”,被认为是需要重新生成的
       command: 命令行，如果不与"targets:prerequisites"在一行，则必须以 Tab 键开头
                如果在同一行，则可用分号隔开
       如果命令过长，可以使用反斜杠(\)作为换行符

   (3)在规则中使用通配符 ： make支持 3 个通配符
      <1> ~  : 与文件目录相关，一般指 $HOME 目录
      <2> *  ： 代替了一系列的文件. 如"*.c"表示所有以.c为后缀的文件
      <3> ..

   (4)文件搜索 -- 变量“VPATH”

   (5)伪目标：
      <1>伪目标并不是一个文件，只是一个标签
      <2>使用：.PHONY:clean
         .PHONY:clean
         clean:
              rm *.o temp

   (6)多目标
      <1>Makefile规则中的目标不止一个
      <2>使用自动化变量"$@"

   (7)静态模式
      <1>静态模式可以更加容易定义多目标的规则
      <2> % 的使用

   (8)自动生成依赖
      <1>自动寻找源文件中包含的头文件，并生成一个依赖
      <2> gcc -MM main.c
      <3> GNU把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个"name.c"的文件
          都生成一个"name.d"的Makefile文件，[.d]文件中就存放对应[.c]文件的依赖的关系


4. Makefile书写命令
   *** 每条命令必须以 [Tab] 键开头
   (1)显示命令
      <1> 使用 @ 字符在命令之前，则该命令将不被make显示出来
          @echo 正在编译XXX模块......
          make执行时，会输出"正在编译XXX模块......"

   (2)执行命令
      <1> 当依赖目标新于目标时，make会一条一条的执行其后的命令
      <2> 如果要让上一条命令的结果应用在下一条命令时，应该使用分号分隔这两条命令

   (3)命令出错
      <1> 如果一个规则中的某个命令出错了，那么make就会执行当前规则
      <2> 忽略命令的出错，可以在Makefile的命令行前加个减号 - (在Tab键之后，注意与空格的区别)

   (4)嵌套执行make
      <1> 对于大型工程，我们可以在每个目录都书写一个该目录的Makefile,然后再有一个总控的Makefile

   (5)定义命令包
      <1> 如果Makefile中出现一些相同命令序列，我们可以为这些相同的命令序列定义一个变量

5. 使用变量
   (1)变量的基础
      <1> 变量在声明时需要给定初值
      <2> 变量在使用时需要在前面加 $ 符号， 且最好用小括号()括起来
      <3> 变量会在使用它的地方精确地展开
          objects = program.o  foo.o  utils.o
          program:$(objects)
             cc -o program $(objects)

          $(objects): defs.h

   (2)变量中的变量
      <1> 在定义变量时，可以使用其他变量来构造变量的值
      <2> Makefile中两种方法：一是 = ; 二是 :=
      <3> := 的好处：前面的变量不能使用后面的变量,只能使用前面已定义好的变量

   (3)变量高级用法
     <1> 变量值的替换
         《1》格式: $(var: a=b), 其意思：把变量"var"中所有的"a"替换成"b"字符串
             foo := a.o b.o c.o
             bar :=$(foo:.o=.c)    // bar :=$(foo:%.o=%.c)
             结果：$(bar)的值就是“a.c b.c c.c”

     <2> 把变量的值再当成变量
        《1》举例：
            x = y
            y = z
            a:=$($(x))

   (4)追加变量值
      <1> 使用"+="符号

   (5)override指示符

   (6)多行变量
      <1> define关键字

   (7)环境变量
      <1> 如果在环境变量中设置了 CFLAGS 环境变量，我们就可以在所有的Makefile中使用这个变量
      <2> 定义在文件中的变量，如果要向下层Makefile传递，则需要使用export关键字来声明

   (8)目标变量
      <1> 前面所讲的都是“全局变量”,我们同样也可以为某个目标设置局部变量，称为"Target-specific Variable"
      <2> 语法：
          <target ...> : <variable-assignment>
          <target ...> : overide<variable-assignment>
      <3> 这个特性非常有用，当我们设置了这样一个变量，这个变量会作用到由这个目标所引发的所有规则中去

   (9)模式变量
      <1> 模式变量的语法与目标变量一致


6. 使用条件判断
   <1> 语法：
      《1》<conditional-directive>      //条件关键字，有四个：ifeq,ifneq,ifdef, ifndef
          <text-if-true>
          endif

       《2》<conditinal-directive>
           <text-if-true>
           else
           <text-if-false>
           endif

   <2> 关键字
       《1》ifeq   ：ifeq(<arg1>,<arg2)      比较参数arg1和arg2的值是否相同
       《2》ifneq  ：ifneq(<arg1>,<arg2)     比较参数arg1和arg2的值是否相同，如果不同，则为真
       《3》ifdef  ：ifdef <variable-name>   如果变量<variable-name>的值非空，则表达式为真。否则表达式为假
       《4》ifndef ：ifndef <variable-name>


7. 使用函数
   (1)函数的调用语法
      <1> 函数的使用，也是用 $ 来标示
      <2> 语法：
          $(<function><arguments)
      <3> 格式：为了风格统一,函数和变量的括号最好一样,如使用 $(subst a,b,$(x))形式


   (2)字符串处理函数
      <1> subst 函数
          格式：subst( <from>,<to>,<text>)
          说明：字符串替换函数
               把字符串<text>中的<from>字符串替换成<to>
               函数返回被替换后的字符串

      <2> patsubst
          格式：$(patsubst <pattern>,<replacement>,<text>)
          说明：模式字符串替换字符

      <3> strip
          格式：$(strip <string>)
          说明：去掉<string>字符串开头和结尾的空字符

      <4> findstring
          格式：$(findstring <find>,<in>)
          说明：在字符串<in>中查找<find>字符串

      <5> filter
          格式:$(filter <pattern...>,<text>)
          说明：过滤函数

      <6> filter-out
          说明：反过滤函数

      <7> sort
          格式：$(sort <list>)
          说明：排序函数
               把字符串<list>中的单词按首字母排序(升序)

      <8> word - 取单词函数

      <9> wordlist - 取单词串函数

      <10> words - 单词个数统计函数

      <11> firstword - 首单词函数


   (3)文件名操作函数
      <1> dir - 取目录函数
      <2> notdir - 取文件函数
      <3> suffix - 取后缀函数
      <4> basename - 取前缀函数
      <5> addsuffix - 加后缀函数
      <6> addprefix - 加前缀函数
      <7> join - 连接函数

   (4)foreach函数
      <1> 语法：$(foreach <var>,<list>,<text>)
      <2> 说明：把参数<list>中的单词逐一取出放到参数<var>所指定的变量中，然后执行<text>中的
               表达式

   (5)if函数
      if函数很像GNU的make所支持的条件语句--ifeq

   (6)call函数
      <1> 语法：$(call <expression>,<parm1>,<parm2>,...,<parmn>)
      <2> 说明：执行make时，<expression>参数中的变量，如$(1),$(2)等，会被参数<parm1>,<parm2>等一次取代

   (7)origin函数
      <1> 语法：$(origin <variable>)
      <2> 说明：告诉我们变量<variable>是哪里来的. <variable>是变量的名字，不应该是引
      <3> Origin函数会根据返回值来告诉我们这个变量的"生出情况"

   (8)shell函数
      <1> 功能：shell函数把执行操作系统命令后的输出作为函数的返回

   (9)控制make的函数
      <1> make提供了一些函数来控制make的运行

8. make的运行
   (1)make的退出码
      0: 表示成功执行
      1: 如果make运行时出现任何错误，其返回1
      2: 如果使用了make的"-q"选项，并且make使得一些目标不需要更新，那么返回2

   (2)指定Makefile
      <1> GNU make寻找默认的Makefile的规则：在当前目录下一次查找--GNUmakefile,makefile,Makefile
      <2> 可以给make命令指定一个特定的Makefile,如makefile名为"hchen.mk",
             make -f hchen.mk

   (3)指定目标
      <1> 一般来说，make的最终目标是makefile中第一个目标.
          可以指定完成的目标，make命令后直接跟目标的名字，如：make clean

      <2>  书写Makefile中的伪目标：
           all:所有目标的目标. 如果把all设置成第一个目标，那么只需要执行make
           clean:删除所有被make所创建的文件
           install:安装以编译好的程序--把目标执行文件拷贝到指定的目标中去
           print:列出改过的源文件
           tar:把源程序打包备份
           dist:创建一个压缩文件
           TAGS:更新所有的目标，以备完整地重编译使用
           check,test:用来测试makefile的流程

   (4)make的参数


9. 隐含规则  (在Makefile中早先约定好了的，不需要我们再写出来的规则)

   (1)使用隐含规则
      <1> 如果要使用隐含规则，需要做的就是不要写出这个目标的规则;
          如果我们书写了自己的规则，那么make就不会自动推到导并盗用隐含规则

   (2)隐含规则一览
      <1> 编译C程序的隐含规则
          <n>.o 的目标的依赖目标会自动推导为<n>.c
          生成命令：$(CC) -c $(CPPFLAGS) $(CFLAGS)

      <2> 编译C++程序的隐含规则
          <n>.o 的目标的依赖目标会自动推导为<n>.cc 或 <n>.C
          生成命令：$(CXX) -c $(CPPFLAGS) $(CFLAGS)

      <3> 编译Pascal程序的隐含规则

      <4> 编译Fortran/Ratfor程序的隐含规则

      <5> 预处理Fortran/Ratfor程序的隐含规则

      <6> 其他规则请自行查找

   (3)隐含规则使用的变量
      <1> 关于命令的变量
          变量             变量说明                       默认命令
          CC            C语言编译程序.                    cc
          CXX           C++语言编译程序.                  g++
          CPP           C程序的预处理器(输出是标准输出设备). $(CC) -E
          RM            删除文件命令                      rm -f

      <2> 关于命令参数的变量
          变量             变量说明
          CFLAGS          C语言比编译器参数
          CXXFLAGS        C++语言编译器参数
          CPPFLAGS        C预处理器参数
          FFLAGS          Fortran语言编译器参数

   (4)隐含规则链

   (5)定义模式规则
      <1> 在模式规则中，目标的定义需要有 % 字符，% 的意思是表示一个或多个任意字符
      <2> 目标中的模式的 % 决定了依赖目标中 % 的样子
      <3> 自动化变量
          《1》自动化变量：把模式中所定义的一系列的文件自耦东地挨个取出，直至所有的符合模式的文件都取完了
          《2》所有的自动化变量：
              $@   表示规则中的目标文件集
              $%   仅当目标是函数库文件时，表示规则中的目标成员名，否则为空.
                   Unix下函数库文件是 .a， Windows下是 .lib
                   如果第一个目标是 foo.a(bar.o)，则 $% 是 bar.o, $@ 是 foo.a
              $(<) 依赖目标中第一个目标的名字
              $?   所有比目标新的依赖目标的集合.以空格隔开
              $^   所有的依赖目标的集合. 以空格隔开. 去除重复的依赖目标
              $+   与 $^很像，也是依赖目标的集合，只是不去除重复的依赖目标
              $*   表示目标模式中 % 及其之前的部分
              $

      <4> 模式的匹配

   (6)老式风格的后缀规则
      <1> 双后缀规则: 目标文件的后缀和依赖目标(源文件)的后缀. 如 .c.o, 相当于 %o : %c
          单后缀规则：只定义一个后缀，即源文件的后缀. 如 .c, 相当于 % : %.c
      <2> 后缀规则不允许任何的依赖文件
      <3> 后缀规则中，如果没有命令，那是毫无意义的

   (7)隐含规则搜索算法


10. 使用make更新函数库文件
   (1)函数库文件的成员
      <1> 函数库文件是对 Object文件的打包文件
      <2> 指定函数库文件及其组成：
          《1》格式：archive(member)
          《2》例子：
               foolib(hack.o) : hack.cerr
                    ar cr foolib hack.o

   (2)函数库成员的隐含规则

   (3)函数库问价你的后缀规则

   (4)注意事项




////////////////////////////////////////////////////////////////////////////////

                           C++ 程序编译常
链接：
   https://www.jianshu.com/p/b8ddb4cee7af


////////////////////////////////////////////////////////////////////////////////

1. GCC编译器

   **** GCC 支持的后缀文件类型：
        后缀名              对应语言
        .c                 C语言
        .C/.cc/.cxx        C++程序
        .i                 预处理后的C程序
        .ii                预处理后的C++程序
        .s/.S              汇编语言程序
        .h                 头文件
        .o                 目标文件
        .a/.so             编译后的库文件

   **** GCC编译流程分为4个步骤:
        预处理: 生成.i/.ii文件
        编译: 生成.s/.S文件
        汇编: 生成.o文件
        链接: 生成可执行文件

   **** gcc指令的一般格式：
         gcc [选项] 要编译的文件 [选项] [目标文件]   //目标文件可省略

   <1> 预处理
      gcc 将 stdio.h 文件中代码包含进这段程序. -E 选项代表让 gcc 在预处理阶段后停止编译
      gcc -E test.c -o test.i

   <2> 编译
       该阶段主要是对预编译后的.i文件编译，生成汇编代码的.s文件
       gcc -S test.i -o test.s

   <3> 汇编
       该阶段是将编译后的.s文件转化成二进制文件.o的过程
       gcc -c test.s -o test.o

   <4> 链接
       该阶段主要将成功编译的二进制文件进行链接操作，生成可执行文件
       gcc test.o -o test

   **** GCC 常用编译选项 -- 总体编译选项
      -c          只编译不链接，生成目标文件.o
      -S          只编译不汇编，生成汇编代码
      -E          只进行预编译，不做其他处理
      -g          在可执行程序中包含标准调试信息
      -o file     把文件输出到file里
      -I dir      在头文件的搜索路径列表中添加dir目录  // -I dir 和 -L dir 都只是指定了路径，
      -L dir      在库文件的搜索路径列表中添加dir目录  // 而没有指定文件，因此不能在路径中包含文件名
      -static     链接静态库
      -llibrary   链接名为library的库文件
      -std=c++11



2. G++编译器
   <1> g++ 的编译过程与gcc基本一致

        hello.c --> 预处理器 --> hello.i --> 编译器 --> hello.s -->汇编器 -->hello.o --> 链接器 -->hello
        源程序        (cpp)      修改了的     (ccl)     汇编程序     (as)    目标程序      (ld)    可执行
        (文本)                   源程序                 (文本)              (二进制)             目标程序
                                (文本)                                                        (二进制)

   <2> g++的参数使用
       《1》-std=<语言标准>
       《2》-o file        // 输出编译后的结果到指定的文件file中
       《3》-E             // 对源文件进行预处理，预处理后生成.i/.ii文件
       《4》-S             // 只进行预处理和编译
       《5》-c             // 只进行预处理，编译，汇编操作，生成.o文件，不进行链接
       《6》-save-temps    // 保留编译产生的中间文件，作用等同于 -E -S -c 同时使用
